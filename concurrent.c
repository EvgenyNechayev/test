/*
 * concurrent.c
 *	  code to handle changes that took place while new table was being created
 */

#include "pg_squeeze.h"

#include "executor/executor.h"
#include "replication/decode.h"
#include "utils/rel.h"

void
decode_concurrent_changes(LogicalDecodingContext *ctx, XLogRecPtr *startptr,
						  XLogRecPtr end_of_wal)
{
	DecodingOutputState	*dstate;
	ResourceOwner	resowner_old;

	/*
	 * Invalidate the "present" cache before moving to "(recent) history".
	 *
	 * The cache entry of the transient relation is not affected (because it
	 * was created by the current transaction), but the tuple descriptor
	 * shouldn't change anymore (as opposed to index info, which we change at
	 * some point, but that shouldn't break the logical decoding).
	 *
	 * Note: The logical changes generated by the transient relation are
	 * eventually ignored, but tuple creation can't be avoided. Thus we ought
	 * to care about using the correct tuple descriptor.
	 */
	InvalidateSystemCaches();

	dstate = (DecodingOutputState *) ctx->output_writer_private;
	resowner_old = CurrentResourceOwner;
	CurrentResourceOwner = dstate->resowner;

	PG_TRY();
	{
		while ((*startptr != InvalidXLogRecPtr && *startptr < end_of_wal) ||
			   (ctx->reader->EndRecPtr != InvalidXLogRecPtr &&
				ctx->reader->EndRecPtr < end_of_wal))
		{
			XLogRecord *record;
			char	   *errm = NULL;

			record = XLogReadRecord(ctx->reader, *startptr, &errm);
			if (errm)
				elog(ERROR, "%s", errm);

			*startptr = InvalidXLogRecPtr;

			if (record != NULL)
				LogicalDecodingProcessRecord(ctx, ctx->reader);

			CHECK_FOR_INTERRUPTS();
		}
		InvalidateSystemCaches();
		CurrentResourceOwner = resowner_old;
	}
	PG_CATCH();
	{
		InvalidateSystemCaches();
		CurrentResourceOwner = resowner_old;
		PG_RE_THROW();
	}
	PG_END_TRY();
}

IndexInsertState *
get_index_insert_state(Relation	relation, Oid ident_index_id)
{
	EState	*estate;
	int	i;
	IndexInsertState	*result;

	result = (IndexInsertState *) palloc0(sizeof(IndexInsertState));
	estate = CreateExecutorState();
	result->econtext = GetPerTupleExprContext(estate);

	result->rri = (ResultRelInfo *) palloc(sizeof(ResultRelInfo));
	InitResultRelInfo(result->rri, relation,  0, 0);
	ExecOpenIndices(result->rri, false);

	/*
	 * Find the relcache entry of the identity index so that we spend no extra
	 * effort to open / close it.
	 */
	for (i = 0; i < result->rri->ri_NumIndices; i++)
	{
		IndexInfo	*ii;
		Relation	ind_rel;

		/*
		 * We don't need ExecInsertIndexTuples() to check exclusion
		 * constraints - the source relation is responsible for those.
		 */
		ii = result->rri->ri_IndexRelationInfo[i];
		ii->ii_ExclusionOps = NULL;
		ii->ii_ExclusionProcs = NULL;
		ii->ii_ExclusionStrats = NULL;

		ind_rel = result->rri->ri_IndexRelationDescs[i];
		if (ind_rel->rd_id == ident_index_id)
			result->ident_index = ind_rel;
	}
	if (result->ident_index == NULL)
		elog(ERROR, "Failed to open identity index");

	/* Only initialize fields needed by ExecInsertIndexTuples(). */
	estate->es_result_relations = estate->es_result_relation_info =
		result->rri;
	estate->es_num_result_relations = 1;
	result->estate = estate;

	return result;
}

void
free_index_insert_state(IndexInsertState *iistate)
{
	ExecCloseIndices(iistate->rri);
	FreeExecutorState(iistate->estate);
	pfree(iistate->rri);
	pfree(iistate);
}

/*
 * Process changes that happened during the initial load.
 *
 * Scan key is passed by caller, so it does not have to be constructed
 * multiple times.
 *
 * Index list is passed explicitly as the relation cache entry is not supposed
 * to reflect changes of our transaction (unless we want to reload it, which
 * seems an overkill).
 *
 * For the same reason, ident_index is passed separate. (XXX The PoC does not
 * create constraints, so relation->rd_replidindex field would be empty
 * anyway. But this approach might change in the future.)
 */
void
process_concurrent_changes(DecodingOutputState *dstate, Relation relation,
						   ScanKey key, int nkeys, IndexInsertState *iistate)
{
	TupleTableSlot	*slot_data, *slot_metadata;
	HeapTuple tup_old = NULL;
	BulkInsertState bistate = NULL;

	slot_metadata = MakeTupleTableSlot();
	ExecSetSlotDescriptor(slot_metadata, dstate->metadata.tupdesc);

	slot_data = MakeTupleTableSlot();
	ExecSetSlotDescriptor(slot_data, dstate->data.tupdesc);
	iistate->econtext->ecxt_scantuple = slot_data;

	while (tuplestore_gettupleslot(dstate->metadata.tupstore, true, false,
								   slot_metadata))
	{
		HeapTuple tup_meta, tup, tup_exist;
		Datum	kind_value[1];
		bool	kind_isnull[1];
		char	change_kind;

		if (!tuplestore_gettupleslot(dstate->data.tupstore, true, false,
									 slot_data))
			elog(ERROR, "The data and metadata slots do not match.");

		/* Find out of what kind current change is. */
		tup_meta = ExecCopySlotTuple(slot_metadata);
		heap_deform_tuple(tup_meta, slot_metadata->tts_tupleDescriptor,
						  kind_value, kind_isnull);
		Assert(!kind_isnull[0]);
		change_kind = DatumGetChar(kind_value[0]);

		/*
		 * Do not keep buffer pinned for insert if the current change is
		 * something else.
		 */
		if (change_kind != PG_SQUEEZE_CHANGE_INSERT && bistate != NULL)
		{
			FreeBulkInsertState(bistate);
			bistate = NULL;
		}

		tup = ExecCopySlotTuple(slot_data);
		if (change_kind == PG_SQUEEZE_CHANGE_UPDATE_OLD)
		{
			Assert(tup_old == NULL);
			tup_old = tup;
		}
		else if (change_kind == PG_SQUEEZE_CHANGE_INSERT)
		{
			List	*recheck;

			Assert(tup_old == NULL);

			/*
			 * If the next change will also be INSERT, we'll try to use the
			 * same buffer.
			 */
			if (bistate == NULL)
				bistate = GetBulkInsertState();

			heap_insert(relation, tup, GetCurrentCommandId(true), 0, bistate);

			/* Update indexes. */
			recheck = ExecInsertIndexTuples(slot_data, &(tup->t_self),
											iistate->estate, false, NULL,
											NIL);

			/*
			 * If recheck is required, it must have been preformed on the
			 * source relation by now. (All the logical changes we process
			 * here are already committed.)
			 */
			list_free(recheck);

			pfree(tup);
		}
		else if (change_kind == PG_SQUEEZE_CHANGE_UPDATE_NEW ||
				 change_kind == PG_SQUEEZE_CHANGE_DELETE)
		{
			HeapTuple	tup_key;
			IndexScanDesc	scan;
			int i;
			ItemPointerData	ctid;

			if (change_kind == PG_SQUEEZE_CHANGE_UPDATE_NEW)
			{
				tup_key = tup_old != NULL ? tup_old : tup;
			}
			else
			{
				Assert(tup_old == NULL);
				tup_key = tup;
			}

			/*
			 * Find the tuple to be updated or deleted.
			 *
			 * XXX Not sure we need PushActiveSnapshot() - as the table is not
			 * visible to other transactions, the xmin, xmax, xip, etc. fields
			 * of the snapshot are not important, and CurrentSnapshot->curcid
			 * should stay consistent with CommandCounterIncrement() even if
			 * GetSnapshotData() gets called anytime.
			 *
			 * XXX As no other transactions are engaged, SnapshotSelf might
			 * seem to prevent us from wasting values of the command counter
			 * (as we do not update catalog here, cache invalidation is not
			 * the reason to increment the counter). However, heap_update()
			 * does require CommandCounterIncrement().
			 */
			scan = index_beginscan(relation, iistate->ident_index,
								   GetTransactionSnapshot(), nkeys, 0);

			index_rescan(scan, key, nkeys, NULL, 0);

			/* Use the incoming tuple to finalize the scan key. */
			for (i = 0; i < scan->numberOfKeys; i++)
			{
				ScanKey	entry;
				bool	isnull;

				entry = &scan->keyData[i];
				entry->sk_argument = heap_getattr(tup_key,
												  entry->sk_attno,
												  relation->rd_att,
												  &isnull);
				Assert(!isnull);
			}
			tup_exist = index_getnext(scan, ForwardScanDirection);
			if (tup_exist == NULL)
				elog(ERROR, "Failed to find target tuple");
			ItemPointerCopy(&tup_exist->t_self, &ctid);
			index_endscan(scan);

			if (change_kind == PG_SQUEEZE_CHANGE_UPDATE_NEW)
			{
				simple_heap_update(relation, &ctid, tup);
				if (!HeapTupleIsHeapOnly(tup))
				{
					List	*recheck;

					recheck = ExecInsertIndexTuples(slot_data, &(tup->t_self),
													iistate->estate, false,
													NULL, NIL);
					list_free(recheck);
				}
			}
			else
				simple_heap_delete(relation, &ctid);

			if (tup_old != NULL)
			{
				pfree(tup_old);
				tup_old = NULL;
			}

			pfree(tup);
		}
		else
			elog(ERROR, "Unrecognized kind of change: %d", change_kind);

		/* If there's any change, make it visible to the next iteration. */
		if (change_kind != PG_SQUEEZE_CHANGE_UPDATE_OLD)
			CommandCounterIncrement();
		pfree(tup_meta);
	}

	/* Cleanup. */
	if (bistate != NULL)
		FreeBulkInsertState(bistate);

	if (tuplestore_gettupleslot(dstate->data.tupstore, true, false,
								slot_data))
		elog(ERROR, "The data and metadata slots do not match.");

	ExecDropSingleTupleTableSlot(slot_data);
	ExecDropSingleTupleTableSlot(slot_metadata);

	tuplestore_clear(dstate->data.tupstore);
	tuplestore_clear(dstate->metadata.tupstore);
}
